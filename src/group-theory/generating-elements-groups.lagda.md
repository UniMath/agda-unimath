# Generating elements of groups

```agda
module group-theory.generating-elements-groups where
```

<details><summary>Imports</summary>

```agda
open import commutative-algebra.commutative-rings

open import elementary-number-theory.integers

open import foundation.action-on-identifications-functions
open import foundation.dependent-pair-types
open import foundation.dependent-products-propositions
open import foundation.embeddings
open import foundation.equivalences
open import foundation.identity-types
open import foundation.images
open import foundation.injective-maps
open import foundation.propositional-maps
open import foundation.propositional-truncations
open import foundation.propositions
open import foundation.raising-universe-levels-unit-type
open import foundation.sets
open import foundation.subtypes
open import foundation.surjective-maps
open import foundation.unit-type
open import foundation.universe-levels

open import group-theory.abelian-groups
open import group-theory.addition-homomorphisms-abelian-groups
open import group-theory.commuting-elements-groups
open import group-theory.conjugation
open import group-theory.endomorphism-rings-abelian-groups
open import group-theory.free-groups-with-one-generator
open import group-theory.full-subgroups
open import group-theory.groups
open import group-theory.homomorphisms-groups
open import group-theory.integer-multiples-of-elements-abelian-groups
open import group-theory.integer-powers-of-elements-groups
open import group-theory.isomorphisms-abelian-groups
open import group-theory.normal-subgroups
open import group-theory.quotient-groups
open import group-theory.subgroups-generated-by-elements-groups
open import group-theory.subsets-groups
open import group-theory.trivial-group-homomorphisms

open import ring-theory.integer-multiples-of-elements-rings
open import ring-theory.rings
open import ring-theory.transporting-ring-structure-along-isomorphisms-abelian-groups
```

</details>

## Idea

An element $g$ of a [group](group-theory.groups.md) `G` is said to be a
**generating element** if the unique morphism `g̃ : ℤ → G` equipped with an
[identification](foundation-core.identity-types.md) `g̃(1) = g` is
[surjective](foundation.surjective-maps.md).
[Equivalently](foundation.logical-equivalences.md), `g` is a generating element
if the [subgroup](group-theory.subgroups.md) `⟨g⟩` of `G`
[generated by the element](group-theory.subgroups-generated-by-elements-groups.md)
`g` is the [full subgroup](group-theory.full-subgroups.md) of `G`. We give in
total four different characterizations of the notion of generating element:

1. The subgroup generated by the element `g` is full.
2. The full subgroup of `G` is generated by the element `g`.
3. The group homomorphism `g̃ : ℤ → G` mapping `1` to `g` is surjective.
4. The evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`.

Of these four equivalent characterizations, we take the first as our standard
definition.

We note that the concept of _group equipped with a generating element_ is subtly
different from the concept of [cyclic group](group-theory.cyclic-groups.md).
Groups equipped with generating elements have a specified generating element as
part of their structure, whereas cyclic groups are groups with the
[property](foundation-core.propositions.md) that there
[exists](foundation.existential-quantification.md) a generating element.

Furthermore, we show that for any group `G` equipped with a generating element,
the evaluation map `hom(G,G) → G` is an
[equivalence](foundation.equivalences.md). Since groups equipped with a
generating element are [abelian](group-theory.abelian-groups.md), it follows
that `hom(G,G)` is the
[endomorphism ring](group-theory.endomorphism-rings-abelian-groups.md) of an
abelian group. The evaluation map on an endomorphism ring is always a group
homomorphism, so it follows from the
[isomorphism](group-theory.isomorphisms-groups.md)

```text
  hom(G,G) ≅ G
```

that any group equipped with a generating element is in fact a
[commutative ring](commutative-algebra.commutative-rings.md). Here we see
another difference between groups equipped with a specified generating element
and cyclic groups: Equipping a cyclic group with the structure of a commutative
ring amounts to equipping the cyclic group with a _specified_ generating
element, which corresponds to the unit element of the commutative ring
structure.

## Definitions

### Generating elements

We state the definition of generating elements in four equivalent ways: An
element `g` generates the group `G` if

1. the subgroup generated by the element `g` is full, or if
2. the full subgroup of `G` is generated by the element `g`, or if
3. the group homomorphism `g̃ : ℤ → G` mapping `1` to `g` is surjective, or if
4. the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`.

#### The standard definition

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-prop-Group : Prop l
  is-generating-element-prop-Group =
    is-full-prop-Subgroup G (subgroup-element-Group G g)

  is-generating-element-Group : UU l
  is-generating-element-Group = type-Prop is-generating-element-prop-Group

  is-prop-is-generating-element-Group : is-prop is-generating-element-Group
  is-prop-is-generating-element-Group =
    is-prop-type-Prop is-generating-element-prop-Group
```

#### The definition where the full subgroup is asserted to be generated by the element

```agda
  is-subgroup-generated-by-element-full-Subgroup : UUω
  is-subgroup-generated-by-element-full-Subgroup =
    is-subgroup-generated-by-element-Group G g (full-Subgroup lzero G)
```

#### The definition where the unique morphism `ℤ → G` mapping `1` to `g` is surjective

```agda
module _
  {l : Level} (G : Group l)
  where

  is-surjective-hom-element-Group : type-Group G → UU l
  is-surjective-hom-element-Group g =
    is-surjective (map-hom-element-Group G g)
```

#### The definition where the evaluation map `hom(G,H) → H` at `g` is an embedding for every `H`

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-emb-ev-element-hom-Group' : (l : Level) → UU (l1 ⊔ lsuc l)
  is-emb-ev-element-hom-Group' l =
    (H : Group l) → is-emb (ev-element-hom-Group G H g)

  is-emb-ev-element-hom-Group : UUω
  is-emb-ev-element-hom-Group =
    {l : Level} → is-emb-ev-element-hom-Group' l

  is-prop-map-ev-element-hom-Group : UUω
  is-prop-map-ev-element-hom-Group =
    {l : Level} (H : Group l) → is-prop-map (ev-element-hom-Group G H g)
```

### The subset of generating elements of a group

```agda
module _
  {l : Level} (G : Group l)
  where

  generating-element-Group : subset-Group l G
  generating-element-Group x = is-generating-element-prop-Group G x
```

### Groups equipped with a generating element

```agda
Group-With-Generating-Element : (l : Level) → UU (lsuc l)
Group-With-Generating-Element l =
  Σ (Group l) (λ G → type-subtype (generating-element-Group G))

module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  group-Group-With-Generating-Element : Group l
  group-Group-With-Generating-Element = pr1 G

  set-Group-With-Generating-Element : Set l
  set-Group-With-Generating-Element =
    set-Group group-Group-With-Generating-Element

  type-Group-With-Generating-Element : UU l
  type-Group-With-Generating-Element =
    type-Group group-Group-With-Generating-Element

  generating-element-Group-With-Generating-Element :
    type-subtype (generating-element-Group group-Group-With-Generating-Element)
  generating-element-Group-With-Generating-Element = pr2 G

  element-Group-With-Generating-Element : type-Group-With-Generating-Element
  element-Group-With-Generating-Element =
    pr1 generating-element-Group-With-Generating-Element

  is-generating-element-element-Group-With-Generating-Element :
    is-generating-element-Group
      group-Group-With-Generating-Element
      element-Group-With-Generating-Element
  is-generating-element-element-Group-With-Generating-Element =
    pr2 generating-element-Group-With-Generating-Element

  ev-element-hom-Group-With-Generating-Element :
    (H : Group l) →
    hom-Group group-Group-With-Generating-Element H → type-Group H
  ev-element-hom-Group-With-Generating-Element H =
    ev-element-hom-Group
      ( group-Group-With-Generating-Element)
      ( H)
      ( element-Group-With-Generating-Element)
```

## Properties

### The four definitions of generating elements are equivalent

#### An element is generating if and only if it generates the full subgroup

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-is-subgroup-generated-by-element-full-Subgroup :
    is-subgroup-generated-by-element-full-Subgroup G g →
    is-generating-element-Group G g
  is-generating-element-is-subgroup-generated-by-element-full-Subgroup H x =
    leq-subgroup-is-subgroup-generated-by-element-Group G g
      ( full-Subgroup lzero G)
      ( subgroup-element-Group G g)
      ( H)
      ( contains-element-subgroup-element-Group G g)
      ( x)
      ( raise-star)

  is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group :
    is-generating-element-Group G g →
    is-subgroup-generated-by-element-full-Subgroup G g
  pr1
    ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
      H K)
    ( u)
    ( x)
    ( v) =
    leq-subgroup-element-Group G g K u x (H x)
  pr2
    ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
      H K)
    ( u) =
    u g raise-star

is-subgroup-generated-by-element-full-subgroup-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-subgroup-generated-by-element-full-Subgroup
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-subgroup-generated-by-element-full-subgroup-Group-With-Generating-Element G =
  is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
    ( is-generating-element-element-Group-With-Generating-Element G)
```

#### An element `g` is generating if and only if the unique map `g̃ : ℤ → G` is surjective

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  is-generating-element-is-surjective-hom-element-Group' :
    (x : type-Group G) (k : ℤ) (p : map-hom-element-Group G g k ＝ x) →
    is-in-subgroup-element-Group G g x
  is-generating-element-is-surjective-hom-element-Group' ._ k refl =
    contains-powers-subgroup-element-Group G g k

  is-generating-element-is-surjective-hom-element-Group :
    is-surjective-hom-element-Group G g → is-generating-element-Group G g
  is-generating-element-is-surjective-hom-element-Group H x =
    apply-universal-property-trunc-Prop
      ( H x)
      ( subset-subgroup-element-Group G g x)
      ( λ (k , p) →
        is-generating-element-is-surjective-hom-element-Group' x k p)

  is-surjective-hom-element-is-generating-element-Group :
    is-generating-element-Group G g → is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-generating-element-Group H x =
    leq-subgroup-is-subgroup-generated-by-element-Group G g
      ( full-Subgroup lzero G)
      ( image-hom-element-Group G g)
      ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
        ( G)
        ( g)
        ( H))
      ( contains-element-image-hom-element-Group G g)
      ( x)
      ( raise-star)

is-surjective-hom-element-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-surjective-hom-element-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-surjective-hom-element-Group-With-Generating-Element G =
  is-surjective-hom-element-is-generating-element-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
    ( is-generating-element-element-Group-With-Generating-Element G)
```

#### If the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`, then `g̃ : ℤ → G` is surjective

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  (U : is-emb-ev-element-hom-Group G g)
  where

  compute-conjugation-is-emb-ev-element-hom-Group :
    htpy-hom-Group G G (conjugation-hom-Group G g) (id-hom-Group G)
  compute-conjugation-is-emb-ev-element-hom-Group =
    htpy-eq-hom-Group G G
      ( conjugation-hom-Group G g)
      ( id-hom-Group G)
      ( is-injective-is-emb (U G)
        ( inv (transpose-eq-mul-Group G refl)))

  commute-is-emb-ev-element-hom-Group :
    (x : type-Group G) → mul-Group G g x ＝ mul-Group G x g
  commute-is-emb-ev-element-hom-Group x =
    inv
      ( inv-transpose-eq-mul-Group G
        ( inv (compute-conjugation-is-emb-ev-element-hom-Group x)))

  compute-conjugation-is-emb-ev-element-hom-Group' :
    (x : type-Group G) → conjugation-Group G x g ＝ g
  compute-conjugation-is-emb-ev-element-hom-Group' x =
    inv (transpose-eq-mul-Group G (commute-is-emb-ev-element-hom-Group x))

  abstract
    is-normal-image-hom-element-is-emb-ev-element-hom-Group :
      is-normal-Subgroup G (image-hom-element-Group G g)
    is-normal-image-hom-element-is-emb-ev-element-hom-Group x (y , p) =
      apply-universal-property-trunc-Prop p
        ( subset-image-hom-element-Group G g (conjugation-Group G x y))
        ( λ where
          ( k , refl) →
            is-closed-under-eq-image-hom-element-Group' G g
              ( unit-trunc-Prop (k , refl))
              ( ( preserves-integer-powers-conjugation-Group G k x g) ∙
                ( ap
                  ( integer-power-Group G k)
                  ( compute-conjugation-is-emb-ev-element-hom-Group' x))))

  private
    N : Normal-Subgroup l G
    pr1 N = image-hom-element-Group G g
    pr2 N = is-normal-image-hom-element-is-emb-ev-element-hom-Group

    H : Group l
    H = quotient-Group G N

    q : hom-Group G H
    q = quotient-hom-Group G N

  abstract
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group :
      is-trivial-hom-Group G H q
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group =
      htpy-eq-hom-Group G H q
        ( trivial-hom-Group G H)
        ( is-injective-is-emb
          ( U H)
          ( inv
            ( is-in-kernel-quotient-hom-is-in-Normal-Subgroup G N
              ( contains-element-image-hom-element-Group G g))))

  is-surjective-hom-element-is-emb-ev-element-hom-Group :
    is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-emb-ev-element-hom-Group x =
    is-in-normal-subgroup-is-in-kernel-quotient-hom-Group G N
      ( inv
        ( is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group
          x))
```

#### A group element `g : G` is generating if and only if for every group `H` the evaluation map `hom(G,H) → H` at `g` is an embedding

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  abstract
    is-prop-map-ev-element-is-generating-element-Group :
      is-generating-element-Group G g → is-prop-map-ev-element-hom-Group G g
    is-prop-map-ev-element-is-generating-element-Group U H y =
      is-prop-all-elements-equal
        ( λ (h , p) (k , q) →
          eq-type-subtype
            ( λ u → Id-Prop (set-Group H) (ev-element-hom-Group G H g u) y)
            ( eq-htpy-hom-Group G H
              ( λ x →
                apply-universal-property-trunc-Prop
                  ( is-surjective-hom-element-is-generating-element-Group
                    G g U x)
                  ( Id-Prop
                    ( set-Group H)
                    ( map-hom-Group G H h x)
                    ( map-hom-Group G H k x))
                  ( λ where
                    ( z , refl) →
                        eq-integer-power-hom-Group G H h k z g (p ∙ inv q)))))

  is-emb-ev-element-is-generating-element-Group :
    is-generating-element-Group G g → is-emb-ev-element-hom-Group G g
  is-emb-ev-element-is-generating-element-Group U H =
    is-emb-is-prop-map (is-prop-map-ev-element-is-generating-element-Group U H)

  is-generating-element-is-emb-ev-element-hom-Group :
    is-emb-ev-element-hom-Group G g → is-generating-element-Group G g
  is-generating-element-is-emb-ev-element-hom-Group U =
    is-generating-element-is-surjective-hom-element-Group G g
      ( is-surjective-hom-element-is-emb-ev-element-hom-Group G g U)

is-emb-ev-element-Group-With-Generating-Element :
  {l : Level} (G : Group-With-Generating-Element l) →
  is-emb-ev-element-hom-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
is-emb-ev-element-Group-With-Generating-Element G =
  is-emb-ev-element-is-generating-element-Group
    ( group-Group-With-Generating-Element G)
    ( element-Group-With-Generating-Element G)
    ( is-generating-element-element-Group-With-Generating-Element G)
```

### If `g` is a generating element of `G`, then `G` is abelian

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  where

  abstract
    commutative-mul-is-surjective-hom-element-Group :
      (U : is-surjective-hom-element-Group G g) →
      (x y : type-Group G) → commute-Group G x y
    commutative-mul-is-surjective-hom-element-Group U x y =
      apply-twice-universal-property-trunc-Prop
        ( U x)
        ( U y)
        ( Id-Prop (set-Group G) (mul-Group G x y) (mul-Group G y x))
        ( λ where
          ( k , refl) (l , refl) →
            commute-integer-powers-Group G k l refl)

  commutative-mul-is-generating-element-Group :
    (U : is-generating-element-Group G g) →
    (x y : type-Group G) → commute-Group G x y
  commutative-mul-is-generating-element-Group U =
    commutative-mul-is-surjective-hom-element-Group
      ( is-surjective-hom-element-is-generating-element-Group G g U)

module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  abelian-group-Group-With-Generating-Element : Ab l
  pr1 abelian-group-Group-With-Generating-Element =
    group-Group-With-Generating-Element G
  pr2 abelian-group-Group-With-Generating-Element =
    commutative-mul-is-generating-element-Group
      ( group-Group-With-Generating-Element G)
      ( element-Group-With-Generating-Element G)
      ( is-generating-element-element-Group-With-Generating-Element G)

  zero-Group-With-Generating-Element :
    type-Group-With-Generating-Element G
  zero-Group-With-Generating-Element =
    zero-Ab abelian-group-Group-With-Generating-Element

  add-Group-With-Generating-Element :
    (x y : type-Group-With-Generating-Element G) →
    type-Group-With-Generating-Element G
  add-Group-With-Generating-Element =
    add-Ab abelian-group-Group-With-Generating-Element

  neg-Group-With-Generating-Element :
    type-Group-With-Generating-Element G → type-Group-With-Generating-Element G
  neg-Group-With-Generating-Element =
    neg-Ab abelian-group-Group-With-Generating-Element

  associative-add-Group-With-Generating-Element :
    (x y z : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element
      ( add-Group-With-Generating-Element x y)
      ( z) ＝
    add-Group-With-Generating-Element
      ( x)
      ( add-Group-With-Generating-Element y z)
  associative-add-Group-With-Generating-Element =
    associative-add-Ab abelian-group-Group-With-Generating-Element

  left-unit-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element zero-Group-With-Generating-Element x ＝ x
  left-unit-law-add-Group-With-Generating-Element =
    left-unit-law-add-Ab abelian-group-Group-With-Generating-Element

  right-unit-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element x zero-Group-With-Generating-Element ＝ x
  right-unit-law-add-Group-With-Generating-Element =
    right-unit-law-add-Ab abelian-group-Group-With-Generating-Element

  left-inverse-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element (neg-Group-With-Generating-Element x) x ＝
    zero-Group-With-Generating-Element
  left-inverse-law-add-Group-With-Generating-Element =
    left-inverse-law-add-Ab abelian-group-Group-With-Generating-Element

  right-inverse-law-add-Group-With-Generating-Element :
    (x : type-Group-With-Generating-Element G) →
    add-Group-With-Generating-Element x (neg-Group-With-Generating-Element x) ＝
    zero-Group-With-Generating-Element
  right-inverse-law-add-Group-With-Generating-Element =
    right-inverse-law-add-Ab abelian-group-Group-With-Generating-Element
```

### If `g` is a generating element of `G`, then the evaluation map `hom(G,G) → G` is an isomorphism of groups

```agda
module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  abstract
    is-surjective-ev-element-Group-With-Generating-Element :
      is-surjective
        ( ev-element-hom-Group-With-Generating-Element G
          ( group-Group-With-Generating-Element G))
    is-surjective-ev-element-Group-With-Generating-Element x =
      apply-universal-property-trunc-Prop
        ( is-surjective-hom-element-Group-With-Generating-Element G x)
        ( subtype-im
          ( ev-element-hom-Group-With-Generating-Element G
            ( group-Group-With-Generating-Element G))
          ( x))
        ( λ where
          ( k , refl) →
            unit-trunc-Prop
              ( hom-integer-multiple-Ab
                  ( abelian-group-Group-With-Generating-Element G)
                  ( k) ,
                refl))

  is-equiv-ev-element-Group-With-Generating-Element :
    is-equiv
      ( ev-element-hom-Group-With-Generating-Element G
        ( group-Group-With-Generating-Element G))
  is-equiv-ev-element-Group-With-Generating-Element =
    is-equiv-is-emb-is-surjective
      ( is-surjective-ev-element-Group-With-Generating-Element)
      ( is-emb-ev-element-Group-With-Generating-Element G
        ( group-Group-With-Generating-Element G))

  is-iso-ev-element-Group-With-Generating-Element :
    is-iso-Ab
      ( ab-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
      ( hom-ev-element-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G)
        ( element-Group-With-Generating-Element G))
  is-iso-ev-element-Group-With-Generating-Element =
    is-iso-is-equiv-hom-Ab
      ( ab-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
      ( hom-ev-element-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G)
        ( element-Group-With-Generating-Element G))
      ( is-equiv-ev-element-Group-With-Generating-Element)

  iso-ev-element-Group-With-Generating-Element :
    iso-Ab
      ( ab-hom-Ab
        ( abelian-group-Group-With-Generating-Element G)
        ( abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
  pr1 iso-ev-element-Group-With-Generating-Element =
    hom-ev-element-hom-Ab
      ( abelian-group-Group-With-Generating-Element G)
      ( abelian-group-Group-With-Generating-Element G)
      ( element-Group-With-Generating-Element G)
  pr2 iso-ev-element-Group-With-Generating-Element =
    is-iso-ev-element-Group-With-Generating-Element
```

### Groups equipped with generating elements are commutative rings

```agda
module _
  {l : Level} (G : Group-With-Generating-Element l)
  where

  ring-Group-With-Generating-Element : Ring l
  ring-Group-With-Generating-Element =
    transport-ring-structure-iso-Ab
      ( endomorphism-ring-Ab (abelian-group-Group-With-Generating-Element G))
      ( abelian-group-Group-With-Generating-Element G)
      ( iso-ev-element-Group-With-Generating-Element G)

  one-Group-With-Generating-Element : type-Group-With-Generating-Element G
  one-Group-With-Generating-Element =
    one-Ring ring-Group-With-Generating-Element

  compute-one-Group-With-Generating-Element :
    one-Group-With-Generating-Element ＝
    element-Group-With-Generating-Element G
  compute-one-Group-With-Generating-Element = refl

  mul-Group-With-Generating-Element :
    (x y : type-Group-With-Generating-Element G) →
    type-Group-With-Generating-Element G
  mul-Group-With-Generating-Element =
    mul-Ring ring-Group-With-Generating-Element

  abstract
    commutative-mul-Group-With-Generating-Element :
      (x y : type-Group-With-Generating-Element G) →
      mul-Group-With-Generating-Element x y ＝
      mul-Group-With-Generating-Element y x
    commutative-mul-Group-With-Generating-Element x y =
      apply-twice-universal-property-trunc-Prop
        ( is-surjective-hom-element-Group-With-Generating-Element G x)
        ( is-surjective-hom-element-Group-With-Generating-Element G y)
        ( Id-Prop (set-Group-With-Generating-Element G) _ _)
        ( λ where
          ( k , refl) (l , refl) →
            commute-integer-multiples-diagonal-Ring
              ( ring-Group-With-Generating-Element)
              ( k)
              ( l))

  commutative-ring-Group-With-Generating-Element : Commutative-Ring l
  pr1 commutative-ring-Group-With-Generating-Element =
    ring-Group-With-Generating-Element
  pr2 commutative-ring-Group-With-Generating-Element =
    commutative-mul-Group-With-Generating-Element
```

## See also

### Table of files related to cyclic types, groups, and rings

{{#include tables/cyclic-types.md}}
