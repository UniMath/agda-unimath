# Kernels of homomorphisms of groups

```agda
module group-theory.kernels-homomorphisms-groups where
```

<details><summary>Imports</summary>

```agda
open import foundation.action-on-identifications-functions
open import foundation.dependent-pair-types
open import foundation.equality-cartesian-product-types
open import foundation.identity-types
open import foundation.propositions
open import foundation.sets
open import foundation.universe-levels

open import foundation-core.injective-maps

open import group-theory.embeddings-groups
open import group-theory.groups
open import group-theory.homomorphisms-groups
open import group-theory.normal-subgroups
open import group-theory.subgroups
open import group-theory.subsets-groups
open import group-theory.trivial-subgroups
```

</details>

## Idea

The **kernel** of a [group homomorphism](group-theory.homomorphisms-groups.md)
`f : G → H` is the [normal subgroup](group-theory.normal-subgroups.md) of `G`
consisting of those elements `x : G` such that `f x ＝ unit-Group H`.

## Definition

We define the kernel as the subgroup generated by the predicate which associates
to `x` the proposition `f(x) = unit`.

```agda
module _
  {l k : Level} (G : Group l) (H : Group k) (f : hom-Group G H)
  where

  subset-kernel-hom-Group : subset-Group k G
  subset-kernel-hom-Group x =
    is-unit-prop-Group' H (map-hom-Group G H f x)

  is-in-kernel-hom-Group : type-Group G → UU k
  is-in-kernel-hom-Group x = type-Prop (subset-kernel-hom-Group x)

  contains-unit-subset-kernel-hom-Group :
    is-in-kernel-hom-Group (unit-Group G)
  contains-unit-subset-kernel-hom-Group = inv (preserves-unit-hom-Group G H f)

  is-closed-under-multiplication-subset-kernel-hom-Group :
    is-closed-under-multiplication-subset-Group G subset-kernel-hom-Group
  is-closed-under-multiplication-subset-kernel-hom-Group p q =
    ( inv (left-unit-law-mul-Group H _)) ∙
    ( ap-mul-Group H p q) ∙
    ( inv (preserves-mul-hom-Group G H f))

  is-closed-under-inverses-subset-kernel-hom-Group :
    is-closed-under-inverses-subset-Group G subset-kernel-hom-Group
  is-closed-under-inverses-subset-kernel-hom-Group p =
    ( inv (inv-unit-Group H)) ∙
    ( ap (inv-Group H) p) ∙
    ( inv (preserves-inv-hom-Group G H f))

  subgroup-kernel-hom-Group : Subgroup k G
  pr1 subgroup-kernel-hom-Group = subset-kernel-hom-Group
  pr1 (pr2 subgroup-kernel-hom-Group) = contains-unit-subset-kernel-hom-Group
  pr1 (pr2 (pr2 subgroup-kernel-hom-Group)) =
    is-closed-under-multiplication-subset-kernel-hom-Group
  pr2 (pr2 (pr2 subgroup-kernel-hom-Group)) =
    is-closed-under-inverses-subset-kernel-hom-Group

  group-kernel-hom-Group : Group (l ⊔ k)
  group-kernel-hom-Group = group-Subgroup G subgroup-kernel-hom-Group

  inclusion-kernel-hom-Group : hom-Group group-kernel-hom-Group G
  inclusion-kernel-hom-Group =
    hom-inclusion-Subgroup G subgroup-kernel-hom-Group

  type-kernel-hom-Group : UU (l ⊔ k)
  type-kernel-hom-Group = type-Subgroup G subgroup-kernel-hom-Group

  map-inclusion-kernel-hom-Group : type-kernel-hom-Group → type-Group G
  map-inclusion-kernel-hom-Group =
    map-hom-Group group-kernel-hom-Group G inclusion-kernel-hom-Group

  is-in-subgroup-inclusion-kernel-hom-Group :
    (x : type-kernel-hom-Group) →
    is-in-kernel-hom-Group (map-inclusion-kernel-hom-Group x)
  is-in-subgroup-inclusion-kernel-hom-Group =
    is-in-subgroup-inclusion-Subgroup G subgroup-kernel-hom-Group

  is-emb-inclusion-kernel-hom-Group :
    is-emb-hom-Group group-kernel-hom-Group G inclusion-kernel-hom-Group
  is-emb-inclusion-kernel-hom-Group =
    is-emb-inclusion-Subgroup G subgroup-kernel-hom-Group

  emb-inclusion-kernel-hom-Group : emb-Group group-kernel-hom-Group G
  pr1 emb-inclusion-kernel-hom-Group =
    inclusion-kernel-hom-Group
  pr2 emb-inclusion-kernel-hom-Group =
    is-emb-inclusion-kernel-hom-Group
```

## Properties

```agda
module _
  {l1 l2 : Level} (G : Group l1) (H : Group l2) (f : hom-Group G H)
  where

  is-normal-kernel-hom-Group :
    is-normal-Subgroup G (subgroup-kernel-hom-Group G H f)
  is-normal-kernel-hom-Group g h =
    inv
      ( ( preserves-mul-hom-Group G H f) ∙
        ( ap
          ( mul-Group' H (map-hom-Group G H f (inv-Group G g)))
          ( ( preserves-mul-hom-Group G H f) ∙
            ( inv
              ( ap
                ( mul-Group H (map-hom-Group G H f g))
                ( is-in-subgroup-inclusion-kernel-hom-Group G H f h))) ∙
            ( right-unit-law-mul-Group H (map-hom-Group G H f g)))) ∙
        ( ap (mul-Group H _) (preserves-inv-hom-Group G H f)) ∙
        ( right-inverse-law-mul-Group H (map-hom-Group G H f g)))

  kernel-hom-Group : Normal-Subgroup l2 G
  pr1 kernel-hom-Group = subgroup-kernel-hom-Group G H f
  pr2 kernel-hom-Group = is-normal-kernel-hom-Group
```

### When `ker f` is [trivial](group-theory.trivial-subgroups.md), `f` is [injective](foundation-core.injective-maps.md)

```agda
module _
  {l1 l2 : Level} (G : Group l1) (H : Group l2) (f : hom-Group G H)
  ( f-ker-triv : is-trivial-Subgroup G (subgroup-kernel-hom-Group G H f))
  where

  kernel-is-trivial-is-injective-Group : is-injective (map-hom-Group G H f)
  kernel-is-trivial-is-injective-Group {x} {y} p = inv lem-3 where
    lem-1 : is-in-kernel-hom-Group G H f (mul-Group G (inv-Group G y) x)
    lem-1 = equational-reasoning
      unit-Group H ＝ mul-Group H (inv-Group H (map-hom-Group G H f y))
      ( map-hom-Group G H f y)
        by inv (left-inverse-law-mul-Group H (pr1 f y))
      ＝ mul-Group H (map-hom-Group G H f (inv-Group G y))
      ( map-hom-Group G H f y)
        by ap (λ z → mul-Group H z (pr1 f y))
        ( inv (preserves-inv-hom-Group G H f))
      ＝ mul-Group H (map-hom-Group G H f (inv-Group G y))
      ( map-hom-Group G H f x)
        by ap (mul-Group H (map-hom-Group G H f (inv-Group G y))) (inv p)
      ＝ map-hom-Group G H f (mul-Group G (inv-Group G y) x)
        by inv (preserves-mul-hom-Group G H f)

    lem-2 : unit-Group G ＝ mul-Group G (inv-Group G y) x
    lem-2 = f-ker-triv (mul-Group G (inv-Group G y) x) lem-1

    lem-3 : y ＝ x
    lem-3 = equational-reasoning
      y ＝ mul-Group G y (unit-Group G)
        by inv (right-unit-law-mul-Group G y)
      ＝ mul-Group G y (mul-Group G (inv-Group G y) x)
        by ap (mul-Group G y) lem-2
      ＝ mul-Group G (mul-Group G y (inv-Group G y)) x
        by inv (associative-mul-Group G y (inv-Group G y) x)
      ＝ mul-Group G (unit-Group G) x
        by ap (λ z → mul-Group G z x) (right-inverse-law-mul-Group G y)
      ＝ x
        by left-unit-law-mul-Group G x

module _
  {l1 l2 : Level} (G : Group l1) (H : Group l2) (f : hom-Group G H)
  where

  is-injective-kernel-is-trivial-Group :
    is-injective (map-hom-Group G H f) → is-trivial-Subgroup G
    ( subgroup-kernel-hom-Group G H f)
  is-injective-kernel-is-trivial-Group f-inj x fx-unit = f-inj lem where
    lem : pr1 f (unit-Group G) ＝ pr1 f x
    lem = preserves-unit-hom-Group G H f ∙ fx-unit
```
