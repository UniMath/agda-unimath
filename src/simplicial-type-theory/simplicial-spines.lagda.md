# The simplicial spines

```agda
module simplicial-type-theory.simplicial-spines where
```

<details><summary>Imports</summary>

```agda
open import elementary-number-theory.natural-numbers

open import foundation.action-on-identifications-functions
open import foundation.booleans
open import foundation.cartesian-product-types
open import foundation.conjunction
open import foundation.contractible-types
open import foundation.coproduct-types
open import foundation.dependent-identifications
open import foundation.dependent-pair-types
open import foundation.disjunction
open import foundation.whiskering-homotopies-composition
open import foundation.empty-types
open import foundation.disjunction
open import foundation.equality-dependent-pair-types
open import foundation.equivalences
open import foundation.function-extensionality
open import foundation.function-types
open import foundation.functoriality-dependent-pair-types
open import foundation.homotopies
open import foundation.identity-types
open import foundation.propositions
open import foundation.retractions
open import foundation.sections
open import foundation.sets
open import foundation.subtypes
open import foundation.type-arithmetic-dependent-pair-types
open import foundation.unit-type
open import foundation.universe-levels

open import reflection.erasing-equality

open import simplicial-type-theory.directed-edges
open import simplicial-type-theory.directed-interval-type
open import simplicial-type-theory.inequality-directed-interval-type
open import simplicial-type-theory.simplicial-arrows
open import simplicial-type-theory.simplicial-cubes

open import synthetic-homotopy-theory.cocones-under-spans
open import synthetic-homotopy-theory.universal-property-pushouts
open import synthetic-homotopy-theory.dependent-universal-property-pushouts
open import synthetic-homotopy-theory.induction-principle-pushouts
open import synthetic-homotopy-theory.recursion-principle-pushouts
open import synthetic-homotopy-theory.dependent-cocones-under-spans
open import synthetic-homotopy-theory.joins-of-types
open import synthetic-homotopy-theory.pushouts

open import univalent-combinatorics.standard-finite-types
```

</details>

## Idea

The {{#concept "ùëõ-spine"}} is the classifying type of chains of directed edges
of length ùëõ.

```text
  0 ---> 1 ----> ... ----> (n-1) ----> n
```

It has the universal property of the iterated
[pushout](synthetic-homotopy-theory.pushouts.md)

```text
               0‚ÇÇ
         1 ---------> ùüö
         |            |
  target |            |
         ‚à®          ‚åú ‚à®
     spine n ----> spine (n + 1)
```

where

```text
  spine 0 := 1.
```

In
[`rewriting-simplicial-spines`](simplicial-type-theory.rewriting-simplicial-spines.md)
we equip the eliminator of the spines with strict computation rules on the point
constructors.

## Postulates

### The type of ùëõ-spines

```agda
postulate
  spine : ‚Ñï ‚Üí UU lzero

  star-spine-0 : spine 0

  contraction-star-spine-0 : (x : spine 0) ‚Üí star-spine-0 Ôºù x

  inl-spine : {n : ‚Ñï} ‚Üí spine n ‚Üí spine (succ-‚Ñï n)

  in-arrow-spine : {n : ‚Ñï} ‚Üí ùüö ‚Üí spine (succ-‚Ñï n)

is-contr-spine-0 : is-contr (spine 0)
is-contr-spine-0 = (star-spine-0 , contraction-star-spine-0)

initial-point-spine : (n : ‚Ñï) ‚Üí spine n
initial-point-spine zero-‚Ñï = star-spine-0
initial-point-spine (succ-‚Ñï n) = inl-spine (initial-point-spine n)

terminal-point-spine : (n : ‚Ñï) ‚Üí spine n
terminal-point-spine zero-‚Ñï = star-spine-0
terminal-point-spine (succ-‚Ñï n) = in-arrow-spine 1‚ÇÇ

postulate
  glue-spine : {n : ‚Ñï} ‚Üí inl-spine (terminal-point-spine n) Ôºù in-arrow-spine {n} 0‚ÇÇ
```

### The induction principle of the (ùëõ+1)-spine

We postulate that the (ùëõ+1)-spine is the pushout

```text
               0‚ÇÇ
         1 ---------> ùüö
         |            |
  target |            |
         ‚à®          ‚åú ‚à®
     spine n -----> spine (n + 1)
```

```agda
cocone-spine :
  (n : ‚Ñï) ‚Üí
  cocone (point (terminal-point-spine n)) (point 0‚ÇÇ) (spine (succ-‚Ñï n))
cocone-spine n = (inl-spine , in-arrow-spine , point glue-spine)

module _
  {l : Level} (n : ‚Ñï) (P : spine (succ-‚Ñï n) ‚Üí UU l)
  (d :
    dependent-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P))
  where

  postulate
    dependent-cogap-spine : (x : spine (succ-‚Ñï n)) ‚Üí P x

  compute-inl-dependent-cogap-spine :
    (x : spine n) ‚Üí
    dependent-cogap-spine (inl-spine x) Ôºù
    horizontal-map-dependent-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P)
      ( d)
      ( x)
  compute-inl-dependent-cogap-spine x =
    primEraseEquality compute-inl-dependent-cogap-spine'
    where
    postulate
      compute-inl-dependent-cogap-spine' :
        dependent-cogap-spine (inl-spine x) Ôºù
        horizontal-map-dependent-cocone
          ( point (terminal-point-spine n))
          ( point 0‚ÇÇ)
          ( cocone-spine n)
          ( P)
          ( d)
          ( x)

  compute-inr-dependent-cogap-spine :
    (t : ùüö) ‚Üí
    dependent-cogap-spine (in-arrow-spine t) Ôºù
    vertical-map-dependent-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P)
      ( d)
      ( t)
  compute-inr-dependent-cogap-spine t =
    primEraseEquality compute-inr-dependent-cogap-spine'
    where
    postulate
      compute-inr-dependent-cogap-spine' :
        dependent-cogap-spine (in-arrow-spine t) Ôºù
        vertical-map-dependent-cocone
          ( point (terminal-point-spine n))
          ( point 0‚ÇÇ)
          ( cocone-spine n)
          ( P)
          ( d)
          ( t)

  postulate
    compute-glue-dependent-cogap-spine :
      coherence-htpy-dependent-cocone
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( P)
        ( dependent-cocone-map
          ( point (terminal-point-spine n))
          ( point 0‚ÇÇ)
          ( cocone-spine n)
          ( P)
          ( dependent-cogap-spine))
        ( d)
        ( compute-inl-dependent-cogap-spine)
        ( compute-inr-dependent-cogap-spine)
```

## Definitions

### The spines as subtypes of the cubes

We can inductively define the ùëõ-spine as a subtype of the ùëõ-cube via t

```text
                 ¬∑ ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ> ‚àô
                ‚àß‚àß        ‚àß‚àß
              ‚ã∞  ‚îÜ      /  ‚îÜ
            ¬∑ ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ> ‚àô    ‚îÜ
  y   x     ‚àß    ¬∑ ‚îÑ‚îÑ ‚àß ‚îÑ> ¬∑
  ‚àß ‚àß       ‚îÜ   ‚àß     |   ‚àß
  |/        ‚îÜ ‚ã∞       | ‚ã∞
  ‚îî-> z     ‚àô ------> ‚àô
```

```agda
subtype-spine : (n : ‚Ñï) ‚Üí subtype lzero (simplicial-cube n)
subtype-spine 0 _ = unit-Prop
subtype-spine 1 _ = unit-Prop
subtype-spine (succ-‚Ñï (succ-‚Ñï n)) (t , x) =
  join-Prop
    ( is-terminal-element-simplicial-cube-Prop (succ-‚Ñï n) x)
    ( (Id-ùüö-Prop t 0‚ÇÇ) ‚àß (subtype-spine (succ-‚Ñï n) x))
```

Let us work out what this definition unfolds to when `n` is `2`:

```text
  subtype-spine 2 (s , t)
  ‚âê is-terminal t ‚à® ((s Ôºù 0‚ÇÇ) ‚àß (subtype-spine 1 t))
  ‚âê (t Ôºù 1‚ÇÇ) ‚à® ((s Ôºù 0‚ÇÇ) ‚àß unit)
  ‚âÉ (t Ôºù 1‚ÇÇ) ‚à® (s Ôºù 0‚ÇÇ).
```

Observe again that the coordinates are read in order from right to left.

```agda
spine' : ‚Ñï ‚Üí UU lzero
spine' n = type-subtype (subtype-spine n)

is-set-spine' : (n : ‚Ñï) ‚Üí is-set (spine' n)
is-set-spine' n =
  is-set-type-subtype (subtype-spine n) (is-set-simplicial-cube n)
```

### The point inclusions of the spines

The ùëõ-spine has ùëõ+1 points that we enumerate

```text
  0 ---> 1 ---> 2 ---> ‚ãØ ---> n
```

```agda
point-spine : (n : ‚Ñï) ‚Üí Fin (succ-‚Ñï n) ‚Üí spine n
point-spine zero-‚Ñï _ = star-spine-0
point-spine (succ-‚Ñï n) (inl x) = inl-spine (point-spine n x)
point-spine (succ-‚Ñï n) (inr x) = terminal-point-spine (succ-‚Ñï n)

compute-inr-point-spine :
  (n : ‚Ñï) {x : unit} ‚Üí point-spine n (inr x) Ôºù terminal-point-spine n
compute-inr-point-spine zero-‚Ñï = refl
compute-inr-point-spine (succ-‚Ñï n) = refl
```

### The arrow inclusions of the spine

The ùëõ-spine has ùëõ arrows.

```agda
arrow-spine : (n : ‚Ñï) ‚Üí Fin n ‚Üí ùüö ‚Üí spine n
arrow-spine (succ-‚Ñï n) (inl x) = inl-spine ‚àò arrow-spine n x
arrow-spine (succ-‚Ñï n) (inr x) = in-arrow-spine
```

### The hom inclusions of the spine

```agda
source-hom-spine : (n : ‚Ñï) (x : Fin n) ‚Üí spine n
source-hom-spine n x = point-spine n (inl-Fin n x)

target-hom-spine : (n : ‚Ñï) (x : Fin n) ‚Üí spine n
target-hom-spine n x = point-spine n (inr-Fin n x)

inv-eq-source-arrow-spine :
  (n : ‚Ñï) (x : Fin n) ‚Üí source-hom-spine n x Ôºù arrow-spine n x 0‚ÇÇ
inv-eq-source-arrow-spine (succ-‚Ñï n) (inl x) =
  ap inl-spine (inv-eq-source-arrow-spine n x)
inv-eq-source-arrow-spine (succ-‚Ñï n) (inr x) =
  ap inl-spine (compute-inr-point-spine n) ‚àô glue-spine

eq-source-arrow-spine :
  (n : ‚Ñï) (x : Fin n) ‚Üí arrow-spine n x 0‚ÇÇ Ôºù source-hom-spine n x
eq-source-arrow-spine n x = inv (inv-eq-source-arrow-spine n x)

eq-target-arrow-spine :
  (n : ‚Ñï) (x : Fin n) ‚Üí arrow-spine n x 1‚ÇÇ Ôºù target-hom-spine n x
eq-target-arrow-spine (succ-‚Ñï n) (inl x) =
  ap inl-spine (eq-target-arrow-spine n x)
eq-target-arrow-spine (succ-‚Ñï n) (inr x) = refl

hom-spine : (n : ‚Ñï) (x : Fin n) ‚Üí source-hom-spine n x ‚Üí‚ÇÇ target-hom-spine n x
hom-spine n x =
  ( arrow-spine n x , eq-source-arrow-spine n x , eq-target-arrow-spine n x)
```

### The dependent universal property of the spines

```agda
module _
  (n : ‚Ñï) {l : Level} (P : spine (succ-‚Ñï n) ‚Üí UU l)
  where

  htpy-compute-dependent-cogap-spine :
    ( c :
      dependent-cocone
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( P)) ‚Üí
    htpy-dependent-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P)
      ( dependent-cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( P)
        ( dependent-cogap-spine n P c))
      ( c)
  htpy-compute-dependent-cogap-spine c =
    ( compute-inl-dependent-cogap-spine n P c ,
      compute-inr-dependent-cogap-spine n P c ,
      compute-glue-dependent-cogap-spine n P c)

  is-section-dependent-cogap-spine :
    is-section
      ( dependent-cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( P))
      ( dependent-cogap-spine n P)
  is-section-dependent-cogap-spine c =
    eq-htpy-dependent-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P)
      ( dependent-cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( P)
        ( dependent-cogap-spine n P c))
      ( c)
      ( htpy-compute-dependent-cogap-spine c)

induction-principle-spine :
  (n : ‚Ñï) ‚Üí
  induction-principle-pushout
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
induction-principle-spine n P =
  ( dependent-cogap-spine n P , is-section-dependent-cogap-spine n P)

is-retraction-dependent-cogap-spine :
  (n : ‚Ñï) {l : Level} (P : spine (succ-‚Ñï n) ‚Üí UU l) ‚Üí
  is-retraction
    ( dependent-cocone-map
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)
      ( P))
    ( dependent-cogap-spine n P)
is-retraction-dependent-cogap-spine n =
  is-retraction-ind-induction-principle-pushout
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
    ( induction-principle-spine n)

dependent-universal-property-spine :
  (n : ‚Ñï) ‚Üí
  dependent-universal-property-pushout
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
dependent-universal-property-spine n P =
  is-equiv-is-invertible
    ( dependent-cogap-spine n P)
    ( is-section-dependent-cogap-spine n P)
    ( is-retraction-dependent-cogap-spine n P)

equiv-dependent-universal-property-spine :
  (n : ‚Ñï) {l : Level} (P : spine (succ-‚Ñï n) ‚Üí UU l) ‚Üí
  ( (x : spine (succ-‚Ñï n)) ‚Üí P x) ‚âÉ
  ( dependent-cocone
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
    ( P))
pr1 (equiv-dependent-universal-property-spine n P) =
  dependent-cocone-map
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
    ( P)
pr2 (equiv-dependent-universal-property-spine n P) =
  dependent-universal-property-spine n P
```

### The universal property of the spines

```agda
module _
  (n : ‚Ñï) {l : Level} {X : UU l}
  where

  cogap-spine :
    cocone (point (terminal-point-spine n)) (point 0‚ÇÇ) X ‚Üí spine (succ-‚Ñï n) ‚Üí X
  cogap-spine =
    dependent-cogap-spine n (Œª _ ‚Üí X) ‚àò
    dependent-cocone-constant-type-family-cocone
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n)

  is-section-cogap-spine :
    is-section
      ( cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n))
      ( cogap-spine)
  is-section-cogap-spine =
    ( ( triangle-dependent-cocone-map-constant-type-family'
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)) ¬∑r
      ( cogap-spine)) ‚àôh
    ( ( cocone-dependent-cocone-constant-type-family
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)) ¬∑l
      ( is-section-dependent-cogap-spine n (Œª _ ‚Üí X)) ¬∑r
      ( dependent-cocone-constant-type-family-cocone
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n))) ‚àôh
    ( is-retraction-cocone-dependent-cocone-constant-type-family
      ( point (terminal-point-spine n))
      ( point 0‚ÇÇ)
      ( cocone-spine n))

  is-retraction-cogap-spine :
    is-retraction
      ( cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n))
      ( cogap-spine)
  is-retraction-cogap-spine =
    ( ( cogap-spine) ¬∑l
      ( triangle-dependent-cocone-map-constant-type-family'
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n))) ‚àôh
    ( ( dependent-cogap-spine n (Œª _ ‚Üí X)) ¬∑l
      ( is-section-cocone-dependent-cocone-constant-type-family
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)) ¬∑r
      ( dependent-cocone-map
        ( point (terminal-point-spine n))
        ( point 0‚ÇÇ)
        ( cocone-spine n)
        ( Œª _ ‚Üí X))) ‚àôh
    ( is-retraction-dependent-cogap-spine n (Œª _ ‚Üí X))

recursion-principle-spine :
  (n : ‚Ñï) ‚Üí
  recursion-principle-pushout
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
recursion-principle-spine n = (cogap-spine n , is-section-cogap-spine n)

universal-property-spine :
  (n : ‚Ñï) ‚Üí
  universal-property-pushout
    ( point (terminal-point-spine n))
    ( point 0‚ÇÇ)
    ( cocone-spine n)
universal-property-spine n Y =
  is-equiv-is-invertible
    ( cogap-spine n)
    ( is-section-cogap-spine n)
    ( is-retraction-cogap-spine n)

equiv-universal-property-spine :
  (n : ‚Ñï) {l : Level} {X : UU l} ‚Üí
  (spine (succ-‚Ñï n) ‚Üí X) ‚âÉ cocone (point (terminal-point-spine n)) (point 0‚ÇÇ) X
equiv-universal-property-spine n {X = X} =
  ( cocone-map (point (terminal-point-spine n)) (point 0‚ÇÇ) (cocone-spine n) ,
    universal-property-spine n X)
```

## Properties

### The ùëõ-spine as a subtype of the ùëõ-cube

This remains to be formalized.

```agda
inl-spine' : (n : ‚Ñï) ‚Üí spine' n ‚Üí spine' (succ-‚Ñï n)
inl-spine' zero-‚Ñï _ = (0‚ÇÇ , star)
inl-spine' (succ-‚Ñï zero-‚Ñï) (t , _) = ((0‚ÇÇ , t) , inr-join (refl , star))
inl-spine' (succ-‚Ñï (succ-‚Ñï n)) x = ((0‚ÇÇ , {!   !}) , inr-join (refl , {!   !}))

terminal-point-spine' : (n : ‚Ñï) ‚Üí spine' n
terminal-point-spine' zero-‚Ñï = star , star
terminal-point-spine' (succ-‚Ñï zero-‚Ñï) = 1‚ÇÇ , star
terminal-point-spine' (succ-‚Ñï (succ-‚Ñï n)) = ({!   !} , {!   !})

cocone-spine' :
  (n : ‚Ñï) ‚Üí
  cocone (point (terminal-point-spine' n)) (point 0‚ÇÇ) (spine' (succ-‚Ñï n))
cocone-spine' = {!   !}

-- map-spine-spine' :
--   (n : ‚Ñï) ‚Üí spine' n ‚Üí spine n
-- map-spine-spine' 0 x = star-spine-0
-- map-spine-spine' 1 (x , u) = in-arrow-spine x
-- map-spine-spine' (succ-‚Ñï (succ-‚Ñï n)) ((t , x) , u) =
--   cogap-join
--     ( spine (succ-‚Ñï (succ-‚Ñï n)))
--     ( ( Œª _ ‚Üí in-arrow-spine t) ,
--       ( Œª rs ‚Üí
--         inl-spine (map-spine-spine' (succ-‚Ñï n) (x , pr2 rs))) ,
--       ( Œª (is-terminal-x , t=0 , s) ‚Üí
--         ( ( ap in-arrow-spine t=0) ‚àô
--           ( inv glue-spine) ‚àô
--           ( ap inl-spine
--             ( compute-inr-map-spine-spine' n (x , s) is-terminal-x)))))
--     ( u)
--   where
--     compute-inr-map-spine-spine' :
--       (n : ‚Ñï) (xs : spine' (succ-‚Ñï n)) ‚Üí
--       is-terminal-element-simplicial-cube (succ-‚Ñï n) (pr1 xs) ‚Üí
--       in-arrow-spine 1‚ÇÇ Ôºù map-spine-spine' (succ-‚Ñï n) xs
--     compute-inr-map-spine-spine' zero-‚Ñï xs is-terminal-x =
--       ap in-arrow-spine (inv is-terminal-x)
--     compute-inr-map-spine-spine' (succ-‚Ñï n) xs is-terminal-x =
--       inv (compute-inl-cogap-join {!   !} {!   !}) ‚àô {!   !}

--   -- where map-spine-spine' (succ-‚Ñï n) (x , s)
```

### The 1-spine is the directed interval

```text
         1 ----------> ùüö
         |             |
         |             |
         ‚à®           ‚åú ‚à®
  1 ‚âÉ spine 0 ----> spine 1
```

This remains to be formalized.
