# The unit type

```agda
{-# OPTIONS --without-K --exact-split #-}

module foundation.unit-type where

open import foundation-core.contractible-types using
  ( is-contr; center; contraction; is-prop-is-contr; is-contr-equiv')
open import foundation-core.dependent-pair-types using (pair; pr1; pr2)
open import foundation-core.equivalences using (is-equiv; _â‰ƒ_)
open import foundation-core.identity-types using (Id; refl)
open import foundation-core.propositions using
  ( is-prop; UU-Prop; is-prop-equiv')
open import foundation-core.sets using (is-set; UU-Set)
open import foundation-core.truncated-types using (is-trunc-succ-is-trunc)
open import foundation-core.truncation-levels using (neg-one-ğ•‹)
open import foundation-core.universe-levels using (Level; lzero; UU)

open import foundation.raising-universe-levels using
  ( raise; equiv-raise; map-raise)
```

## Idea

The unit type is inductively generated by one point.

## Definition

### The unit type

```agda
data unit : UU lzero where
  star : unit

ind-unit : {l : Level} {P : unit â†’ UU l} â†’ P star â†’ ((x : unit) â†’ P x)
ind-unit p star = p

terminal-map : {l : Level} {A : UU l} â†’ A â†’ unit
terminal-map a = star
```

### Raising the universe level of the unit type

```agda
raise-unit : (l : Level) â†’ UU l
raise-unit l = raise l unit

raise-star : {l : Level} â†’ raise l unit
raise-star = map-raise star

equiv-raise-unit : (l : Level) â†’ unit â‰ƒ raise-unit l
equiv-raise-unit l = equiv-raise l unit
```

## Properties

### The unit type is contractible

```agda
abstract
  is-contr-unit : is-contr unit
  pr1 is-contr-unit = star
  pr2 is-contr-unit star = refl
```

### Any contractible type is equivalent to the unit type

```agda
module _
  {l : Level} {A : UU l}
  where

  abstract
    is-equiv-terminal-map-is-contr :
      is-contr A â†’ is-equiv (terminal-map {A = A})
    pr1 (pr1 (is-equiv-terminal-map-is-contr H)) = ind-unit (center H)
    pr2 (pr1 (is-equiv-terminal-map-is-contr H)) = ind-unit refl
    pr1 (pr2 (is-equiv-terminal-map-is-contr H)) x = center H
    pr2 (pr2 (is-equiv-terminal-map-is-contr H)) = contraction H

  abstract
    is-contr-is-equiv-const : is-equiv (terminal-map {A = A}) â†’ is-contr A
    pr1 (is-contr-is-equiv-const (pair (pair g issec) (pair h isretr))) = h star
    pr2 (is-contr-is-equiv-const (pair (pair g issec) (pair h isretr))) = isretr
```

### The unit type is a proposition

```agda
abstract
  is-prop-unit : is-prop unit
  is-prop-unit = is-prop-is-contr is-contr-unit

unit-Prop : UU-Prop lzero
pr1 unit-Prop = unit
pr2 unit-Prop = is-prop-unit
```

### The unit type is a set

```agda
abstract
  is-set-unit : is-set unit
  is-set-unit = is-trunc-succ-is-trunc neg-one-ğ•‹ is-prop-unit

unit-Set : UU-Set lzero
pr1 unit-Set = unit
pr2 unit-Set = is-set-unit
```

```agda
abstract
  is-contr-raise-unit :
    {l1 : Level} â†’ is-contr (raise-unit l1)
  is-contr-raise-unit {l1} =
    is-contr-equiv' unit (equiv-raise l1 unit) is-contr-unit

abstract
  is-prop-raise-unit :
    {l1 : Level} â†’ is-prop (raise-unit l1)
  is-prop-raise-unit {l1} =
    is-prop-equiv' (equiv-raise l1 unit) is-prop-unit

raise-unit-Prop :
  (l1 : Level) â†’ UU-Prop l1
pr1 (raise-unit-Prop l1) = raise-unit l1
pr2 (raise-unit-Prop l1) = is-prop-raise-unit
```
