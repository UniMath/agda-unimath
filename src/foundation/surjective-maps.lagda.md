# Surjective maps

```agda
module foundation.surjective-maps where
```

<details><summary>Imports</summary>

```agda
open import foundation.action-on-identifications-functions
open import foundation.connected-maps
open import foundation.contractible-types
open import foundation.dependent-pair-types
open import foundation.diagonal-maps-of-types
open import foundation.embeddings
open import foundation.equality-cartesian-product-types
open import foundation.functoriality-cartesian-product-types
open import foundation.fundamental-theorem-of-identity-types
open import foundation.homotopy-induction
open import foundation.identity-types
open import foundation.inhabited-types
open import foundation.postcomposition-dependent-functions
open import foundation.propositional-truncations
open import foundation.split-surjective-maps
open import foundation.structure-identity-principle
open import foundation.subtype-identity-principle
open import foundation.truncated-types
open import foundation.univalence
open import foundation.universal-property-family-of-fibers-of-maps
open import foundation.universal-property-propositional-truncation
open import foundation.universe-levels

open import foundation-core.cartesian-product-types
open import foundation-core.constant-maps
open import foundation-core.contractible-maps
open import foundation-core.equivalences
open import foundation-core.fibers-of-maps
open import foundation-core.function-types
open import foundation-core.functoriality-dependent-function-types
open import foundation-core.homotopies
open import foundation-core.precomposition-dependent-functions
open import foundation-core.propositional-maps
open import foundation-core.propositions
open import foundation-core.sections
open import foundation-core.sets
open import foundation-core.subtypes
open import foundation-core.torsorial-type-families
open import foundation-core.truncated-maps
open import foundation-core.truncation-levels

open import orthogonal-factorization-systems.extensions-maps
```

</details>

## Idea

A map `f : A ‚Üí B` is **surjective** if all of its
[fibers](foundation-core.fibers-of-maps.md) are
[inhabited](foundation.inhabited-types.md).

## Definition

### Surjective maps

```agda
is-surjective-Prop :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} ‚Üí (A ‚Üí B) ‚Üí Prop (l1 ‚äî l2)
is-surjective-Prop {B = B} f = Œ†-Prop B (trunc-Prop ‚àò fiber f)

is-surjective :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} ‚Üí (A ‚Üí B) ‚Üí UU (l1 ‚äî l2)
is-surjective f = type-Prop (is-surjective-Prop f)

is-prop-is-surjective :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Üí B) ‚Üí
  is-prop (is-surjective f)
is-prop-is-surjective f = is-prop-type-Prop (is-surjective-Prop f)

infix 5 _‚Ü†_
_‚Ü†_ : {l1 l2 : Level} ‚Üí UU l1 ‚Üí UU l2 ‚Üí UU (l1 ‚äî l2)
A ‚Ü† B = Œ£ (A ‚Üí B) is-surjective

module _
  {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Ü† B)
  where

  map-surjection : A ‚Üí B
  map-surjection = pr1 f

  is-surjective-map-surjection : is-surjective map-surjection
  is-surjective-map-surjection = pr2 f
```

### The type of all surjective maps out of a type

```agda
Surjection : {l1 : Level} (l2 : Level) ‚Üí UU l1 ‚Üí UU (l1 ‚äî lsuc l2)
Surjection l2 A = Œ£ (UU l2) (A ‚Ü†_)

module _
  {l1 l2 : Level} {A : UU l1} (f : Surjection l2 A)
  where

  type-Surjection : UU l2
  type-Surjection = pr1 f

  surjection-Surjection : A ‚Ü† type-Surjection
  surjection-Surjection = pr2 f

  map-Surjection : A ‚Üí type-Surjection
  map-Surjection = map-surjection surjection-Surjection

  is-surjective-map-Surjection : is-surjective map-Surjection
  is-surjective-map-Surjection =
    is-surjective-map-surjection surjection-Surjection
```

### The type of all surjective maps into `k`-truncated types

```agda
Surjection-Into-Truncated-Type :
  {l1 : Level} (l2 : Level) (k : ùïã) ‚Üí UU l1 ‚Üí UU (l1 ‚äî lsuc l2)
Surjection-Into-Truncated-Type l2 k A =
  Œ£ (Truncated-Type l2 k) (Œª X ‚Üí A ‚Ü† type-Truncated-Type X)

emb-inclusion-Surjection-Into-Truncated-Type :
  {l1 : Level} (l2 : Level) (k : ùïã) (A : UU l1) ‚Üí
  Surjection-Into-Truncated-Type l2 k A ‚Ü™ Surjection l2 A
emb-inclusion-Surjection-Into-Truncated-Type l2 k A =
  emb-Œ£ (Œª X ‚Üí A ‚Ü† X) (emb-type-Truncated-Type l2 k) (Œª X ‚Üí id-emb)

inclusion-Surjection-Into-Truncated-Type :
  {l1 l2 : Level} {k : ùïã} {A : UU l1} ‚Üí
  Surjection-Into-Truncated-Type l2 k A ‚Üí Surjection l2 A
inclusion-Surjection-Into-Truncated-Type {l1} {l2} {k} {A} =
  map-emb (emb-inclusion-Surjection-Into-Truncated-Type l2 k A)

module _
  {l1 l2 : Level} {k : ùïã} {A : UU l1}
  (f : Surjection-Into-Truncated-Type l2 k A)
  where

  truncated-type-Surjection-Into-Truncated-Type : Truncated-Type l2 k
  truncated-type-Surjection-Into-Truncated-Type = pr1 f

  type-Surjection-Into-Truncated-Type : UU l2
  type-Surjection-Into-Truncated-Type =
    type-Truncated-Type truncated-type-Surjection-Into-Truncated-Type

  is-trunc-type-Surjection-Into-Truncated-Type :
    is-trunc k type-Surjection-Into-Truncated-Type
  is-trunc-type-Surjection-Into-Truncated-Type =
    is-trunc-type-Truncated-Type
      truncated-type-Surjection-Into-Truncated-Type

  surjection-Surjection-Into-Truncated-Type :
    A ‚Ü† type-Surjection-Into-Truncated-Type
  surjection-Surjection-Into-Truncated-Type = pr2 f

  map-Surjection-Into-Truncated-Type :
    A ‚Üí type-Surjection-Into-Truncated-Type
  map-Surjection-Into-Truncated-Type =
    map-surjection surjection-Surjection-Into-Truncated-Type

  is-surjective-Surjection-Into-Truncated-Type :
    is-surjective map-Surjection-Into-Truncated-Type
  is-surjective-Surjection-Into-Truncated-Type =
    is-surjective-map-surjection surjection-Surjection-Into-Truncated-Type
```

### The type of all surjective maps into sets

```agda
Surjection-Into-Set :
  {l1 : Level} (l2 : Level) ‚Üí UU l1 ‚Üí UU (l1 ‚äî lsuc l2)
Surjection-Into-Set l2 A = Surjection-Into-Truncated-Type l2 zero-ùïã A

emb-inclusion-Surjection-Into-Set :
  {l1 : Level} (l2 : Level) (A : UU l1) ‚Üí
  Surjection-Into-Set l2 A ‚Ü™ Surjection l2 A
emb-inclusion-Surjection-Into-Set l2 A =
  emb-inclusion-Surjection-Into-Truncated-Type l2 zero-ùïã A

inclusion-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} ‚Üí
  Surjection-Into-Set l2 A ‚Üí Surjection l2 A
inclusion-Surjection-Into-Set {l1} {l2} {A} =
  inclusion-Surjection-Into-Truncated-Type

module _
  {l1 l2 : Level} {A : UU l1} (f : Surjection-Into-Set l2 A)
  where

  set-Surjection-Into-Set : Set l2
  set-Surjection-Into-Set = truncated-type-Surjection-Into-Truncated-Type f

  type-Surjection-Into-Set : UU l2
  type-Surjection-Into-Set = type-Surjection-Into-Truncated-Type f

  is-set-type-Surjection-Into-Set : is-set type-Surjection-Into-Set
  is-set-type-Surjection-Into-Set =
    is-trunc-type-Surjection-Into-Truncated-Type f

  surjection-Surjection-Into-Set : A ‚Ü† type-Surjection-Into-Set
  surjection-Surjection-Into-Set = surjection-Surjection-Into-Truncated-Type f

  map-Surjection-Into-Set : A ‚Üí type-Surjection-Into-Set
  map-Surjection-Into-Set = map-Surjection-Into-Truncated-Type f

  is-surjective-Surjection-Into-Set : is-surjective map-Surjection-Into-Set
  is-surjective-Surjection-Into-Set =
    is-surjective-Surjection-Into-Truncated-Type f
```

## Properties

### Any map that has a section is surjective

```agda
abstract
  is-surjective-has-section :
    {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí
    section f ‚Üí is-surjective f
  is-surjective-has-section (g , G) b = unit-trunc-Prop (g b , G b)
```

### Any split surjective map is surjective

```agda
abstract
  is-surjective-is-split-surjective :
    {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí
    is-split-surjective f ‚Üí is-surjective f
  is-surjective-is-split-surjective H x =
    unit-trunc-Prop (H x)
```

### Any equivalence is surjective

```agda
module _
  {l1 l2 : Level} {A : UU l1} {B : UU l2}
  where

  is-surjective-is-equiv : {f : A ‚Üí B} ‚Üí is-equiv f ‚Üí is-surjective f
  is-surjective-is-equiv H = is-surjective-has-section (pr1 H)

  is-surjective-map-equiv : (e : A ‚âÉ B) ‚Üí is-surjective (map-equiv e)
  is-surjective-map-equiv e = is-surjective-is-equiv (is-equiv-map-equiv e)

  surjection-equiv : A ‚âÉ B ‚Üí A ‚Ü† B
  surjection-equiv e = map-equiv e , is-surjective-map-equiv e

  surjection-inv-equiv : B ‚âÉ A ‚Üí A ‚Ü† B
  surjection-inv-equiv e = surjection-equiv (inv-equiv e)
```

### The identity function is surjective

```agda
module _
  {l : Level} {A : UU l}
  where

  is-surjective-id : is-surjective (id {A = A})
  is-surjective-id a = unit-trunc-Prop (a , refl)
```

### Maps which are homotopic to surjective maps are surjective

```agda
module _
  { l1 l2 : Level} {A : UU l1} {B : UU l2}
  where

  abstract
    is-surjective-htpy :
      {f g : A ‚Üí B} ‚Üí f ~ g ‚Üí is-surjective g ‚Üí is-surjective f
    is-surjective-htpy {f} {g} H K b =
      apply-universal-property-trunc-Prop
        ( K b)
        ( trunc-Prop (fiber f b))
        ( Œª where (a , refl) ‚Üí unit-trunc-Prop (a , H a))

  abstract
    is-surjective-htpy' :
      {f g : A ‚Üí B} ‚Üí f ~ g ‚Üí is-surjective f ‚Üí is-surjective g
    is-surjective-htpy' H = is-surjective-htpy (inv-htpy H)
```

### The dependent universal property of surjective maps

```agda
module _
  {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Üí B)
  where

  dependent-universal-property-surjection : UUœâ
  dependent-universal-property-surjection =
    {l : Level} (P : B ‚Üí Prop l) ‚Üí
    is-equiv (Œª (h : (b : B) ‚Üí type-Prop (P b)) x ‚Üí h (f x))

  abstract
    is-surjective-dependent-universal-property-surjection :
      dependent-universal-property-surjection ‚Üí is-surjective f
    is-surjective-dependent-universal-property-surjection dup-surj-f =
      map-inv-is-equiv
        ( dup-surj-f (Œª b ‚Üí trunc-Prop (fiber f b)))
        ( Œª x ‚Üí unit-trunc-Prop (x , refl))

  abstract
    square-dependent-universal-property-surjection :
      {l3 : Level} (P : B ‚Üí Prop l3) ‚Üí
      ( Œª (h : (y : B) ‚Üí type-Prop (P y)) x ‚Üí h (f x)) ~
      ( ( Œª h x ‚Üí h (f x) (x , refl)) ‚àò
        ( Œª h y ‚Üí h y ‚àò unit-trunc-Prop) ‚àò
        ( postcomp-Œ† _
          ( Œª {y} ‚Üí
            diagonal-exponential
              ( type-Prop (P y))
              ( type-trunc-Prop (fiber f y)))))
    square-dependent-universal-property-surjection P = refl-htpy

  abstract
    dependent-universal-property-surjection-is-surjective :
      is-surjective f ‚Üí dependent-universal-property-surjection
    dependent-universal-property-surjection-is-surjective is-surj-f P =
      is-equiv-comp
        ( Œª h x ‚Üí h (f x) (x , refl))
        ( ( Œª h y ‚Üí h y ‚àò unit-trunc-Prop) ‚àò
          ( postcomp-Œ†
            ( B)
            ( Œª {y} ‚Üí
              diagonal-exponential
                ( type-Prop (P y))
                ( type-trunc-Prop (fiber f y)))))
        ( is-equiv-comp
          ( Œª h y ‚Üí h y ‚àò unit-trunc-Prop)
          ( postcomp-Œ†
            ( B)
            ( Œª {y} ‚Üí
              diagonal-exponential
                ( type-Prop (P y))
                ( type-trunc-Prop (fiber f y))))
          ( is-equiv-map-Œ†-is-fiberwise-equiv
            ( Œª y ‚Üí
              is-equiv-diagonal-exponential-is-contr
                ( is-proof-irrelevant-is-prop
                  ( is-prop-type-trunc-Prop)
                  ( is-surj-f y))
                ( type-Prop (P y))))
          ( is-equiv-map-Œ†-is-fiberwise-equiv
            ( Œª b ‚Üí is-propositional-truncation-trunc-Prop (fiber f b) (P b))))
        ( universal-property-family-of-fibers-fiber f (is-in-subtype P))

  equiv-dependent-universal-property-surjection-is-surjective :
    is-surjective f ‚Üí
    {l : Level} (C : B ‚Üí Prop l) ‚Üí
    ((b : B) ‚Üí type-Prop (C b)) ‚âÉ ((a : A) ‚Üí type-Prop (C (f a)))
  pr1 (equiv-dependent-universal-property-surjection-is-surjective H C) h x =
    h (f x)
  pr2 (equiv-dependent-universal-property-surjection-is-surjective H C) =
    dependent-universal-property-surjection-is-surjective H C

  apply-dependent-universal-property-surjection-is-surjective :
    is-surjective f ‚Üí
    {l : Level} (C : B ‚Üí Prop l) ‚Üí
    ((a : A) ‚Üí type-Prop (C (f a))) ‚Üí ((y : B) ‚Üí type-Prop (C y))
  apply-dependent-universal-property-surjection-is-surjective H C =
    map-inv-equiv
      ( equiv-dependent-universal-property-surjection-is-surjective H C)

  apply-twice-dependent-universal-property-surjection-is-surjective :
    is-surjective f ‚Üí
    {l : Level} (C : B ‚Üí B ‚Üí Prop l) ‚Üí
    ((x y : A) ‚Üí type-Prop (C (f x) (f y))) ‚Üí ((s t : B) ‚Üí type-Prop (C s t))
  apply-twice-dependent-universal-property-surjection-is-surjective H C G s =
    apply-dependent-universal-property-surjection-is-surjective
      ( H)
      ( Œª b ‚Üí C s b)
      ( Œª y ‚Üí
        apply-dependent-universal-property-surjection-is-surjective
          ( H)
          ( Œª b ‚Üí C b (f y))
          ( Œª x ‚Üí G x y)
          ( s))

equiv-dependent-universal-property-surjection :
  {l l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Ü† B) ‚Üí
  (C : B ‚Üí Prop l) ‚Üí
  ((b : B) ‚Üí type-Prop (C b)) ‚âÉ ((a : A) ‚Üí type-Prop (C (map-surjection f a)))
equiv-dependent-universal-property-surjection f =
  equiv-dependent-universal-property-surjection-is-surjective
    ( map-surjection f)
    ( is-surjective-map-surjection f)

apply-dependent-universal-property-surjection :
  {l l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Ü† B) ‚Üí
  (C : B ‚Üí Prop l) ‚Üí
  ((a : A) ‚Üí type-Prop (C (map-surjection f a))) ‚Üí ((y : B) ‚Üí type-Prop (C y))
apply-dependent-universal-property-surjection f =
  apply-dependent-universal-property-surjection-is-surjective
    ( map-surjection f)
    ( is-surjective-map-surjection f)
```

### A map into a proposition is a propositional truncation if and only if it is surjective

```agda
abstract
  is-surjective-is-propositional-truncation :
    {l1 l2 : Level} {A : UU l1} {P : Prop l2} (f : A ‚Üí type-Prop P) ‚Üí
    dependent-universal-property-propositional-truncation P f ‚Üí
    is-surjective f
  is-surjective-is-propositional-truncation f duppt-f =
    is-surjective-dependent-universal-property-surjection f duppt-f

abstract
  is-propsitional-truncation-is-surjective :
    {l1 l2 : Level} {A : UU l1} {P : Prop l2} (f : A ‚Üí type-Prop P) ‚Üí
    is-surjective f ‚Üí
    dependent-universal-property-propositional-truncation P f
  is-propsitional-truncation-is-surjective f is-surj-f =
    dependent-universal-property-surjection-is-surjective f is-surj-f
```

### A map that is both surjective and an embedding is an equivalence

```agda
abstract
  is-equiv-is-emb-is-surjective :
    {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí
    is-surjective f ‚Üí is-emb f ‚Üí is-equiv f
  is-equiv-is-emb-is-surjective {f = f} H K =
    is-equiv-is-contr-map
      ( Œª y ‚Üí
        is-proof-irrelevant-is-prop
          ( is-prop-map-is-emb K y)
          ( apply-universal-property-trunc-Prop
            ( H y)
            ( fiber-emb-Prop (f , K) y)
            ( id)))
```

### The composite of surjective maps is surjective

```agda
module _
  {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
  where

  abstract
    is-surjective-left-map-triangle :
      (f : A ‚Üí X) (g : B ‚Üí X) (h : A ‚Üí B) (H : f ~ g ‚àò h) ‚Üí
      is-surjective g ‚Üí is-surjective h ‚Üí is-surjective f
    is-surjective-left-map-triangle f g h H is-surj-g is-surj-h x =
      apply-universal-property-trunc-Prop
        ( is-surj-g x)
        ( trunc-Prop (fiber f x))
        ( Œª where
          ( b , refl) ‚Üí
            apply-universal-property-trunc-Prop
              ( is-surj-h b)
              ( trunc-Prop (fiber f (g b)))
              ( Œª where (a , refl) ‚Üí unit-trunc-Prop (a , H a)))

  is-surjective-comp :
    {g : B ‚Üí X} {h : A ‚Üí B} ‚Üí
    is-surjective g ‚Üí is-surjective h ‚Üí is-surjective (g ‚àò h)
  is-surjective-comp {g} {h} =
    is-surjective-left-map-triangle (g ‚àò h) g h refl-htpy

  comp-surjection : B ‚Ü† X ‚Üí A ‚Ü† B ‚Üí A ‚Ü† X
  comp-surjection (g , G) (h , H) = g ‚àò h , is-surjective-comp G H
```

### Functoriality of products preserves being surjective

```agda
module _
  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : UU l3} {D : UU l4}
  where

  is-surjective-map-product :
    {f : A ‚Üí C} {g : B ‚Üí D} ‚Üí
    is-surjective f ‚Üí is-surjective g ‚Üí is-surjective (map-product f g)
  is-surjective-map-product {f} {g} s s' (c , d) =
    apply-twice-universal-property-trunc-Prop
      ( s c)
      ( s' d)
      ( trunc-Prop (fiber (map-product f g) (c , d)))
      ( Œª x y ‚Üí
        unit-trunc-Prop ((pr1 x , pr1 y) , eq-pair (pr2 x) (pr2 y)))

  surjection-product :
    (A ‚Ü† C) ‚Üí (B ‚Ü† D) ‚Üí ((A √ó B) ‚Ü† (C √ó D))
  pr1 (surjection-product f g) =
    map-product (map-surjection f) (map-surjection g)
  pr2 (surjection-product f g) =
    is-surjective-map-product
      ( is-surjective-map-surjection f)
      ( is-surjective-map-surjection g)
```

### The composite of a surjective map before an equivalence is surjective

```agda
is-surjective-left-comp-equiv :
  {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
  (e : B ‚âÉ C) {f : A ‚Üí B} ‚Üí is-surjective f ‚Üí is-surjective (map-equiv e ‚àò f)
is-surjective-left-comp-equiv e =
  is-surjective-comp (is-surjective-map-equiv e)
```

### The composite of a surjective map after an equivalence is surjective

```agda
is-surjective-right-comp-equiv :
  {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3} {f : B ‚Üí C} ‚Üí
  is-surjective f ‚Üí (e : A ‚âÉ B) ‚Üí is-surjective (f ‚àò map-equiv e)
is-surjective-right-comp-equiv H e =
  is-surjective-comp H (is-surjective-map-equiv e)
```

### If a composite is surjective, then so is its left factor

```agda
module _
  {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
  where

  abstract
    is-surjective-right-map-triangle :
      (f : A ‚Üí X) (g : B ‚Üí X) (h : A ‚Üí B) (H : f ~ (g ‚àò h)) ‚Üí
      is-surjective f ‚Üí is-surjective g
    is-surjective-right-map-triangle f g h H is-surj-f x =
      apply-universal-property-trunc-Prop
        ( is-surj-f x)
        ( trunc-Prop (fiber g x))
        ( Œª where (a , refl) ‚Üí unit-trunc-Prop (h a , inv (H a)))

  is-surjective-left-factor :
    {g : B ‚Üí X} (h : A ‚Üí B) ‚Üí is-surjective (g ‚àò h) ‚Üí is-surjective g
  is-surjective-left-factor {g} h =
    is-surjective-right-map-triangle (g ‚àò h) g h refl-htpy
```

### Surjective maps are `-1`-connected

```agda
is-neg-one-connected-map-is-surjective :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí
  is-surjective f ‚Üí is-connected-map neg-one-ùïã f
is-neg-one-connected-map-is-surjective H b =
  is-proof-irrelevant-is-prop is-prop-type-trunc-Prop (H b)

is-surjective-is-neg-one-connected-map :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí
  is-connected-map neg-one-ùïã f ‚Üí is-surjective f
is-surjective-is-neg-one-connected-map H b = center (H b)
```

### A (k+1)-connected map is surjective

```agda
is-surjective-is-connected-map :
  {l1 l2 : Level} (k : ùïã) {A : UU l1} {B : UU l2}
  {f : A ‚Üí B} ‚Üí is-connected-map (succ-ùïã k) f ‚Üí
  is-surjective f
is-surjective-is-connected-map neg-two-ùïã H =
  is-surjective-is-neg-one-connected-map H
is-surjective-is-connected-map (succ-ùïã k) H =
  is-surjective-is-connected-map
    ( k)
    ( is-connected-map-is-connected-map-succ-ùïã
      ( succ-ùïã k)
      ( H))
```

### Precomposing functions into a family of `k+1`-types by a surjective map is a `k`-truncated map

```agda
is-trunc-map-precomp-Œ†-is-surjective :
  {l1 l2 l3 : Level} (k : ùïã) ‚Üí
  {A : UU l1} {B : UU l2} {f : A ‚Üí B} ‚Üí is-surjective f ‚Üí
  (P : B ‚Üí Truncated-Type l3 (succ-ùïã k)) ‚Üí
  is-trunc-map k (precomp-Œ† f (Œª b ‚Üí type-Truncated-Type (P b)))
is-trunc-map-precomp-Œ†-is-surjective k H =
  is-trunc-map-precomp-Œ†-is-connected-map
    ( neg-one-ùïã)
    ( succ-ùïã k)
    ( k)
    ( refl)
    ( is-neg-one-connected-map-is-surjective H)
```

### Characterization of the identity type of `A ‚Ü† B`

```agda
module _
  {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Ü† B)
  where

  htpy-surjection : (A ‚Ü† B) ‚Üí UU (l1 ‚äî l2)
  htpy-surjection g = map-surjection f ~ map-surjection g

  refl-htpy-surjection : htpy-surjection f
  refl-htpy-surjection = refl-htpy

  is-torsorial-htpy-surjection : is-torsorial htpy-surjection
  is-torsorial-htpy-surjection =
    is-torsorial-Eq-subtype
      ( is-torsorial-htpy (map-surjection f))
      ( is-prop-is-surjective)
      ( map-surjection f)
      ( refl-htpy)
      ( is-surjective-map-surjection f)

  htpy-eq-surjection :
    (g : A ‚Ü† B) ‚Üí (f Ôºù g) ‚Üí htpy-surjection g
  htpy-eq-surjection .f refl = refl-htpy-surjection

  is-equiv-htpy-eq-surjection :
    (g : A ‚Ü† B) ‚Üí is-equiv (htpy-eq-surjection g)
  is-equiv-htpy-eq-surjection =
    fundamental-theorem-id is-torsorial-htpy-surjection htpy-eq-surjection

  extensionality-surjection :
    (g : A ‚Ü† B) ‚Üí (f Ôºù g) ‚âÉ htpy-surjection g
  pr1 (extensionality-surjection g) = htpy-eq-surjection g
  pr2 (extensionality-surjection g) = is-equiv-htpy-eq-surjection g

  eq-htpy-surjection : (g : A ‚Ü† B) ‚Üí htpy-surjection g ‚Üí f Ôºù g
  eq-htpy-surjection g =
    map-inv-equiv (extensionality-surjection g)
```

### Characterization of the identity type of `Surjection l2 A`

```agda
equiv-Surjection :
  {l1 l2 l3 : Level} {A : UU l1} ‚Üí
  Surjection l2 A ‚Üí Surjection l3 A ‚Üí UU (l1 ‚äî l2 ‚äî l3)
equiv-Surjection f g =
  Œ£ ( type-Surjection f ‚âÉ type-Surjection g)
    ( Œª e ‚Üí (map-equiv e ‚àò map-Surjection f) ~ map-Surjection g)

module _
  {l1 l2 : Level} {A : UU l1} (f : Surjection l2 A)
  where

  id-equiv-Surjection : equiv-Surjection f f
  pr1 id-equiv-Surjection = id-equiv
  pr2 id-equiv-Surjection = refl-htpy

  is-torsorial-equiv-Surjection :
    is-torsorial (equiv-Surjection f)
  is-torsorial-equiv-Surjection =
    is-torsorial-Eq-structure
      ( is-torsorial-equiv (type-Surjection f))
      ( type-Surjection f , id-equiv)
      ( is-torsorial-htpy-surjection (surjection-Surjection f))

  equiv-eq-Surjection :
    (g : Surjection l2 A) ‚Üí (f Ôºù g) ‚Üí equiv-Surjection f g
  equiv-eq-Surjection .f refl = id-equiv-Surjection

  is-equiv-equiv-eq-Surjection :
    (g : Surjection l2 A) ‚Üí is-equiv (equiv-eq-Surjection g)
  is-equiv-equiv-eq-Surjection =
    fundamental-theorem-id
      is-torsorial-equiv-Surjection
      equiv-eq-Surjection

  extensionality-Surjection :
    (g : Surjection l2 A) ‚Üí (f Ôºù g) ‚âÉ equiv-Surjection f g
  pr1 (extensionality-Surjection g) = equiv-eq-Surjection g
  pr2 (extensionality-Surjection g) = is-equiv-equiv-eq-Surjection g

  eq-equiv-Surjection :
    (g : Surjection l2 A) ‚Üí equiv-Surjection f g ‚Üí f Ôºù g
  eq-equiv-Surjection g = map-inv-equiv (extensionality-Surjection g)
```

### Characterization of the identity type of `Surjection-Into-Truncated-Type l2 k A`

```agda
equiv-Surjection-Into-Truncated-Type :
  {l1 l2 l3 : Level} {k : ùïã} {A : UU l1} ‚Üí
  Surjection-Into-Truncated-Type l2 k A ‚Üí
  Surjection-Into-Truncated-Type l3 k A ‚Üí UU (l1 ‚äî l2 ‚äî l3)
equiv-Surjection-Into-Truncated-Type f g =
  equiv-Surjection
    ( inclusion-Surjection-Into-Truncated-Type f)
    ( inclusion-Surjection-Into-Truncated-Type g)

module _
  {l1 l2 : Level} {k : ùïã} {A : UU l1}
  (f : Surjection-Into-Truncated-Type l2 k A)
  where

  id-equiv-Surjection-Into-Truncated-Type :
    equiv-Surjection-Into-Truncated-Type f f
  id-equiv-Surjection-Into-Truncated-Type =
    id-equiv-Surjection (inclusion-Surjection-Into-Truncated-Type f)

  extensionality-Surjection-Into-Truncated-Type :
    (g : Surjection-Into-Truncated-Type l2 k A) ‚Üí
    (f Ôºù g) ‚âÉ equiv-Surjection-Into-Truncated-Type f g
  extensionality-Surjection-Into-Truncated-Type g =
    ( extensionality-Surjection
      ( inclusion-Surjection-Into-Truncated-Type f)
      ( inclusion-Surjection-Into-Truncated-Type g)) ‚àòe
    ( equiv-ap-emb (emb-inclusion-Surjection-Into-Truncated-Type l2 k A))

  equiv-eq-Surjection-Into-Truncated-Type :
    (g : Surjection-Into-Truncated-Type l2 k A) ‚Üí
    (f Ôºù g) ‚Üí equiv-Surjection-Into-Truncated-Type f g
  equiv-eq-Surjection-Into-Truncated-Type g =
    map-equiv (extensionality-Surjection-Into-Truncated-Type g)

  refl-equiv-eq-Surjection-Into-Truncated-Type :
    equiv-eq-Surjection-Into-Truncated-Type f refl Ôºù
    id-equiv-Surjection-Into-Truncated-Type
  refl-equiv-eq-Surjection-Into-Truncated-Type = refl

  eq-equiv-Surjection-Into-Truncated-Type :
    (g : Surjection-Into-Truncated-Type l2 k A) ‚Üí
    equiv-Surjection-Into-Truncated-Type f g ‚Üí f Ôºù g
  eq-equiv-Surjection-Into-Truncated-Type g =
    map-inv-equiv (extensionality-Surjection-Into-Truncated-Type g)
```

### The type `Surjection-Into-Truncated-Type l2 (succ-ùïã k) A` is `k`-truncated

This remains to be shown.
[#735](https://github.com/UniMath/agda-unimath/issues/735)

### Characterization of the identity type of `Surjection-Into-Set l2 A`

```agda
equiv-Surjection-Into-Set :
  {l1 l2 l3 : Level} {A : UU l1} ‚Üí Surjection-Into-Set l2 A ‚Üí
  Surjection-Into-Set l3 A ‚Üí UU (l1 ‚äî l2 ‚äî l3)
equiv-Surjection-Into-Set = equiv-Surjection-Into-Truncated-Type

id-equiv-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} (f : Surjection-Into-Set l2 A) ‚Üí
  equiv-Surjection-Into-Set f f
id-equiv-Surjection-Into-Set = id-equiv-Surjection-Into-Truncated-Type

extensionality-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} (f g : Surjection-Into-Set l2 A) ‚Üí
  (f Ôºù g) ‚âÉ equiv-Surjection-Into-Set f g
extensionality-Surjection-Into-Set =
  extensionality-Surjection-Into-Truncated-Type

equiv-eq-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} (f g : Surjection-Into-Set l2 A) ‚Üí
  (f Ôºù g) ‚Üí equiv-Surjection-Into-Set f g
equiv-eq-Surjection-Into-Set = equiv-eq-Surjection-Into-Truncated-Type

refl-equiv-eq-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} (f : Surjection-Into-Set l2 A) ‚Üí
  equiv-eq-Surjection-Into-Set f f refl Ôºù
  id-equiv-Surjection-Into-Set f
refl-equiv-eq-Surjection-Into-Set = refl-equiv-eq-Surjection-Into-Truncated-Type

eq-equiv-Surjection-Into-Set :
  {l1 l2 : Level} {A : UU l1} (f g : Surjection-Into-Set l2 A) ‚Üí
  equiv-Surjection-Into-Set f g ‚Üí f Ôºù g
eq-equiv-Surjection-Into-Set = eq-equiv-Surjection-Into-Truncated-Type
```

### Postcomposition of extensions along surjective maps by an embedding is an equivalence

```agda
module _
  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} {Y : UU l4}
  where

  is-surjective-postcomp-extension-surjective-map :
    (f : A ‚Üí B) (i : A ‚Üí X) (g : X ‚Üí Y) ‚Üí
    is-surjective f ‚Üí is-emb g ‚Üí
    is-surjective (postcomp-extension f i g)
  is-surjective-postcomp-extension-surjective-map f i g H K (h , L) =
    unit-trunc-Prop
      ( ( j , N) ,
        ( eq-htpy-extension f
          ( g ‚àò i)
          ( postcomp-extension f i g (j , N))
          ( h , L)
          ( M)
          ( Œª a ‚Üí
            ( ap
              ( concat' (g (i a)) (M (f a)))
              ( is-section-map-inv-is-equiv
                ( K (i a) (j (f a)))
                ( L a ‚àô inv (M (f a))))) ‚àô
            ( is-section-inv-concat' (M (f a)) (L a)))))
    where

    J : (b : B) ‚Üí fiber g (h b)
    J =
      apply-dependent-universal-property-surjection-is-surjective f H
        ( Œª b ‚Üí fiber-emb-Prop (g , K) (h b))
        ( Œª a ‚Üí (i a , L a))

    j : B ‚Üí X
    j b = pr1 (J b)

    M : (g ‚àò j) ~ h
    M b = pr2 (J b)

    N : i ~ (j ‚àò f)
    N a = map-inv-is-equiv (K (i a) (j (f a))) (L a ‚àô inv (M (f a)))

  is-equiv-postcomp-extension-is-surjective :
    (f : A ‚Üí B) (i : A ‚Üí X) (g : X ‚Üí Y) ‚Üí
    is-surjective f ‚Üí is-emb g ‚Üí
    is-equiv (postcomp-extension f i g)
  is-equiv-postcomp-extension-is-surjective f i g H K =
    is-equiv-is-emb-is-surjective
      ( is-surjective-postcomp-extension-surjective-map f i g H K)
      ( is-emb-postcomp-extension f i g K)

  equiv-postcomp-extension-surjection :
    (f : A ‚Ü† B) (i : A ‚Üí X) (g : X ‚Ü™ Y) ‚Üí
    extension (map-surjection f) i ‚âÉ
    extension (map-surjection f) (map-emb g ‚àò i)
  pr1 (equiv-postcomp-extension-surjection f i g) =
    postcomp-extension (map-surjection f) i (map-emb g)
  pr2 (equiv-postcomp-extension-surjection f i g) =
    is-equiv-postcomp-extension-is-surjective
      ( map-surjection f)
      ( i)
      ( map-emb g)
      ( is-surjective-map-surjection f)
      ( is-emb-map-emb g)
```

### Every type that surjects onto an inhabited type is inhabited

```agda
module _
  {l1 l2 : Level} {A : UU l1} {B : UU l2}
  where

  is-inhabited-is-surjective :
    {f : A ‚Üí B} ‚Üí is-surjective f ‚Üí is-inhabited B ‚Üí is-inhabited A
  is-inhabited-is-surjective F =
    rec-trunc-Prop
      ( is-inhabited-Prop A)
      ( rec-trunc-Prop (is-inhabited-Prop A) (unit-trunc-Prop ‚àò pr1) ‚àò F)

  is-inhabited-surjection :
    A ‚Ü† B ‚Üí is-inhabited B ‚Üí is-inhabited A
  is-inhabited-surjection f =
    is-inhabited-is-surjective (is-surjective-map-surjection f)
```

### The type of surjections `A ‚Ü† B` is equivalent to the type of families `P` of inhabited types over `B` equipped with an equivalence `A ‚âÉ Œ£ B P`

This remains to be shown.
[#735](https://github.com/UniMath/agda-unimath/issues/735)

## See also

- In
  [Epimorphisms with respect to sets](foundation.epimorphisms-with-respect-to-sets.md)
  we show that a map is surjective if and only if it is an epimorphism with
  respect to sets.
