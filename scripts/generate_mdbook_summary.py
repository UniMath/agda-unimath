#!/usr/bin/env python3
# Run this script:
# $ ./scripts/generate_mdbook_summary.py book/SUMMARY.md

import argparse
import sys
import utils
import pathlib
import subprocess

STATUS_FLAG_GIT_ERROR = 1
STATUS_FLAG_NO_TITLE = 2
STATUS_FLAG_DUPLICATE_TITLE = 4
STATUS_FAILED_OVERWRITE = 8

entry_template = '- [{title}]({mdfile})'

LITERATURE_MODULE = 'literature'


def generate_namespace_entry_list(root_path, namespace):
    status = 0

    try:
        git_tracked_files = utils.get_git_tracked_files()
    except subprocess.CalledProcessError:
        utils.eprint('Failed to get Git-tracked files')
        sys.exit(STATUS_FLAG_GIT_ERROR)

    namespace_path = root_path.joinpath(namespace)

    # Filter out the relevant files in the given namespace
    relevant_files = tuple(
        f for f in git_tracked_files if namespace_path in f.parents)

    lagda_file_paths = tuple(
        f for f in relevant_files if utils.is_agda_file(f))
    modules = tuple(p.name for p in lagda_file_paths)
    module_titles = tuple(utils.get_lagda_md_file_title(f)
                          for f in lagda_file_paths)
    module_mdfiles = tuple(utils.get_module_mdfile(namespace, m)
                           for m in modules)

    # Check for missing titles
    for title, module in zip(module_titles, modules):
        if title is None:
            status |= STATUS_FLAG_NO_TITLE
            utils.eprint(
                f'WARNING! {namespace}.{module} no title was found')

    # Check duplicate titles
    equal_titles = utils.get_equivalence_classes(
        lambda tf1, tf2: tf1[0] == tf2[0], zip(module_titles, modules))
    equal_titles = tuple(filter(lambda ec: len(
        ec) > 1 and ec[0][0] is not None, equal_titles))

    if (len(equal_titles) > 0):
        status |= STATUS_FLAG_DUPLICATE_TITLE
        utils.eprint(f'WARNING! Duplicate titles in {namespace}:')
        for ec in equal_titles:
            utils.eprint(
                f"  Title '{ec[0][0]}': {', '.join(m[1][:m[1].rfind('.lagda.md')] for m in ec)}")

    module_titles_and_mdfiles = sorted(
        zip(module_titles, module_mdfiles), key=lambda tm: (tm[1].split('.')))

    entry_list = ('  ' + entry_template.format(title=t, mdfile=md)
                  for t, md in module_titles_and_mdfiles)

    namespace_title = utils.get_lagda_md_file_title(
        str(namespace_path.with_suffix('.lagda.md')))
    namespace_entry = entry_template.format(
        title=namespace_title, mdfile=namespace + '.md')

    namespace_entry_list = namespace_entry + '\n' + '\n'.join(entry_list)
    return namespace_entry_list, status


def generate_index(root_path):
    status = 0
    entry_lists = []
    namespaces = sorted(set(utils.get_subdirectories_recursive(root_path)))

    for namespace in namespaces:
        if namespace == LITERATURE_MODULE:
            continue
        entry_list, s = generate_namespace_entry_list(root_path, namespace)
        entry_lists.append(entry_list)
        status |= s

    literature_index, lit_status = generate_namespace_entry_list(
        root_path, LITERATURE_MODULE)
    status |= lit_status

    index = '\n\n'.join(entry_lists) + '\n'
    return index, literature_index, status


summary_template = """\
# SUMMARY

<!--
This file is automatically generated. To add or change entries,
you need to change the template in ./scripts/generate_mdbook_summary.py
-->

# Overview

- [Home](HOME.md)
- [Community](CONTRIBUTORS.md)
  - [Maintainers](MAINTAINERS.md)
  - [Contributors](CONTRIBUTORS.md)
  - [Statement of inclusivity](STATEMENT-OF-INCLUSIVITY.md)
  - [Projects using agda-unimath](PROJECTS.md)
  - [Grant acknowledgments](GRANT-ACKNOWLEDGMENTS.md)
- [Guides](HOWTO-INSTALL.md)
  - [Installing the library](HOWTO-INSTALL.md)
  - [Design principles](DESIGN-PRINCIPLES.md)
  - [Contributing to the library](CONTRIBUTING.md)
  - [Structuring your file](FILE-CONVENTIONS.md)
      - [File template](TEMPLATE.lagda.md)
  - [The library coding style](CODINGSTYLE.md)
  - [Guidelines for mixfix operators](MIXFIX-OPERATORS.md)
  - [Citing sources](CITING-SOURCES.md)
  - [Citing the library](CITE-THIS-LIBRARY.md)
- [Library explorer](VISUALIZATION.md)
- [Art](ART.md)
- [Full list of contents](SUMMARY.md)
{literature_index}

# The agda-unimath library

{module_index}
"""

if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Generate mdbook SUMMARY file. Usage: generate_mdbook_summary.py <OUTPUT_FILE>')
    parser.add_argument(
        'output_file', help='Output file path to write the generated SUMMARY markdown content to.')
    parser.add_argument('--root', help='Root path to source.',
                        default='src', required=False)

    args = parser.parse_args()

    root = args.root
    summary_path = args.output_file

    root_path = pathlib.Path(root)

    module_index, literature_index, status = generate_index(root_path)
    if status == 0:
        summary_contents = summary_template.format(
            literature_index=literature_index,
            module_index=module_index
        )
        summary_file_path = pathlib.Path(summary_path)
        try:
            if summary_file_path.exists():
                existing = summary_file_path.read_text()
                if existing == summary_contents:
                    print(f'No changes to {summary_file_path}.')
                else:
                    summary_file_path.write_text(summary_contents)
                    print(
                        f'Updated mdbook summary content at {summary_file_path}.')
            else:
                summary_file_path.parent.mkdir(parents=True, exist_ok=True)
                summary_file_path.write_text(summary_contents)
                print(f'Wrote mdbook summary content to {summary_file_path}.')
        except Exception as e:
            utils.eprint(
                f'Failed to write summary file {summary_file_path}: {e}')
            status |= STATUS_FAILED_OVERWRITE
    sys.exit(status)
